"""Redis Streams-backed queue manager implementation for the A2A Python SDK."""

import json
import time
from typing import Any, Dict, List, Optional, Tuple

import redis
from a2a.server.events.queue_manager import QueueManager


class RedisQueueManager(QueueManager):
    """Redis Streams-backed implementation of the A2A QueueManager interface."""
    
    def __init__(
        self,
        redis_client: redis.Redis,
        stream_name: str = "a2a:events",
        consumer_group: str = "a2a-agents",
        max_len: Optional[int] = 10000,
        trim_strategy: str = "maxlen"
    ):
        """Initialize the Redis queue manager.
        
        Args:
            redis_client: Redis client instance
            stream_name: Name of the Redis stream
            consumer_group: Consumer group name for agents
            max_len: Maximum stream length (None for unlimited)
            trim_strategy: Stream trimming strategy ('maxlen' or 'minid')
        """
        self.redis = redis_client
        self.stream_name = stream_name
        self.consumer_group = consumer_group
        self.max_len = max_len
        self.trim_strategy = trim_strategy
        
        # Initialize consumer group if it doesn't exist
        self._ensure_consumer_group()
    
    def _ensure_consumer_group(self) -> None:
        """Ensure the consumer group exists."""
        try:
            self.redis.xgroup_create(
                self.stream_name,
                self.consumer_group,
                id="0",
                mkstream=True
            )
        except redis.ResponseError as e:
            # Group already exists
            if "BUSYGROUP" not in str(e):
                raise
    
    def _serialize_event(self, event: Dict[str, Any]) -> Dict[str, str]:
        """Serialize event data for Redis storage."""
        serialized = {}
        for key, value in event.items():
            if isinstance(value, (dict, list)):
                serialized[key] = json.dumps(value)
            else:
                serialized[key] = str(value)
        return serialized
    
    def _deserialize_event(self, event_data: Dict[bytes, bytes]) -> Dict[str, Any]:
        """Deserialize event data from Redis."""
        result = {}
        for key, value in event_data.items():
            key_str = key.decode() if isinstance(key, bytes) else key
            value_str = value.decode() if isinstance(value, bytes) else value
            
            # Try to deserialize JSON data
            try:
                result[key_str] = json.loads(value_str)
            except json.JSONDecodeError:
                result[key_str] = value_str
        
        return result
    
    def enqueue(self, event: Dict[str, Any]) -> str:
        """Add an event to the queue.
        
        Args:
            event: Event data dictionary
            
        Returns:
            Event ID generated by Redis
        """
        serialized_event = self._serialize_event(event)
        
        # Add timestamp if not present
        if "timestamp" not in serialized_event:
            serialized_event["timestamp"] = str(int(time.time() * 1000))
        
        # Add to stream with optional trimming
        if self.max_len:
            event_id = self.redis.xadd(
                self.stream_name,
                serialized_event,
                maxlen=self.max_len,
                approximate=True
            )
        else:
            event_id = self.redis.xadd(self.stream_name, serialized_event)
        
        return event_id.decode() if isinstance(event_id, bytes) else event_id
    
    def dequeue(
        self,
        consumer_id: str,
        count: int = 1,
        block: int = 0,
        auto_claim_min_idle: Optional[int] = None
    ) -> List[Tuple[str, Dict[str, Any]]]:
        """Read events from the queue for a specific consumer.
        
        Args:
            consumer_id: Unique identifier for the consumer
            count: Maximum number of events to read
            block: Block for this many milliseconds (0 = don't block)
            auto_claim_min_idle: Auto-claim messages idle for this many ms
            
        Returns:
            List of (event_id, event_data) tuples
        """
        # Auto-claim pending messages if specified
        if auto_claim_min_idle:
            try:
                claimed = self.redis.xautoclaim(
                    self.stream_name,
                    self.consumer_group,
                    consumer_id,
                    min_idle_time=auto_claim_min_idle,
                    count=count
                )
                if claimed and claimed[1]:  # claimed[1] contains the messages
                    return [
                        (msg_id.decode(), self._deserialize_event(fields))
                        for msg_id, fields in claimed[1]
                    ]
            except redis.ResponseError:
                # Auto-claim not supported or failed, continue with normal read
                pass
        
        # Read new messages
        try:
            messages = self.redis.xreadgroup(
                self.consumer_group,
                consumer_id,
                {self.stream_name: ">"},
                count=count,
                block=block
            )
            
            if not messages:
                return []
            
            # Extract messages from the response
            result = []
            for stream, msgs in messages:
                for msg_id, fields in msgs:
                    event_id = msg_id.decode() if isinstance(msg_id, bytes) else msg_id
                    event_data = self._deserialize_event(fields)
                    result.append((event_id, event_data))
            
            return result
            
        except redis.ResponseError as e:
            if "NOGROUP" in str(e):
                self._ensure_consumer_group()
                return self.dequeue(consumer_id, count, block, auto_claim_min_idle)
            raise
    
    def ack(self, consumer_id: str, event_ids: List[str]) -> int:
        """Acknowledge processing of events.
        
        Args:
            consumer_id: Consumer that processed the events
            event_ids: List of event IDs to acknowledge
            
        Returns:
            Number of messages acknowledged
        """
        if not event_ids:
            return 0
        
        return self.redis.xack(self.stream_name, self.consumer_group, *event_ids)
    
    def pending_count(self, consumer_id: Optional[str] = None) -> int:
        """Get count of pending messages.
        
        Args:
            consumer_id: Specific consumer ID, or None for all consumers
            
        Returns:
            Number of pending messages
        """
        try:
            if consumer_id:
                pending = self.redis.xpending_range(
                    self.stream_name,
                    self.consumer_group,
                    min="-",
                    max="+",
                    count=1
                )
                return len(pending)
            else:
                pending_info = self.redis.xpending(self.stream_name, self.consumer_group)
                return pending_info["pending"]
        except redis.ResponseError:
            return 0
    
    def get_consumer_info(self) -> List[Dict[str, Any]]:
        """Get information about consumers in the group.
        
        Returns:
            List of consumer information dictionaries
        """
        try:
            consumers = self.redis.xinfo_consumers(self.stream_name, self.consumer_group)
            return [
                {
                    "name": consumer[b"name"].decode(),
                    "pending": consumer[b"pending"],
                    "idle": consumer[b"idle"]
                }
                for consumer in consumers
            ]
        except redis.ResponseError:
            return []
    
    def trim_stream(self, max_len: Optional[int] = None) -> None:
        """Manually trim the stream to manage memory usage.
        
        Args:
            max_len: Maximum length to trim to (uses instance default if None)
        """
        trim_len = max_len or self.max_len
        if trim_len:
            self.redis.xtrim(self.stream_name, maxlen=trim_len, approximate=True)
    
    def delete_consumer(self, consumer_id: str) -> bool:
        """Delete a consumer from the consumer group.
        
        Args:
            consumer_id: Consumer ID to delete
            
        Returns:
            True if consumer was deleted, False otherwise
        """
        try:
            result = self.redis.xgroup_delconsumer(
                self.stream_name,
                self.consumer_group,
                consumer_id
            )
            return bool(result)
        except redis.ResponseError:
            return False
    
    def get_stream_info(self) -> Dict[str, Any]:
        """Get information about the stream.
        
        Returns:
            Stream information dictionary
        """
        try:
            info = self.redis.xinfo_stream(self.stream_name)
            return {
                "length": info[b"length"],
                "first_entry": info[b"first-entry"],
                "last_entry": info[b"last-entry"],
                "groups": info[b"groups"]
            }
        except redis.ResponseError:
            return {}